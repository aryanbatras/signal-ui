# Hero Section 

## Title
Signal UI
### Title Subheading
Simple. Clean. Intent-driven.

## Elaborate.

Copy and own all components with one command.
Edit and customize them with a single line of code.
Self-documentating components with clear layer separation.
Based on intent-driven signal design pattern for clean, maintainable code.
No dependency hell and version conflicts. Based on React & Tailwindv4.
No need to remember or read docs for api. Everything is self-documenting.
No variant & size props anymore. Direct intent. Just tell it what you want.
Vscode extension for direct signal suggestions. No more guessing what props to pass.
Still in early stage of development. Edit and customize the components.

## Core Philosophy Behind Signal UI

" A component should be infintely customisable with a single line of code without breaking any existing component functionality while piling up your ideas in the component file that you can freely use with intent. "

" A component should be based on the idea of intention. If I want a large button with a ripple effect, I just tell it that. No props, no variants, no confusion. The component knows what you mean. You express your intent, and the component delivers. "

" Each component should have the idea of dimensions. Since every dimension has infinite variations of intent. An intent knows which dimensions to affect. These dimensions define the visual and behavioral characteristics of the component. For example, a button's size, color, border style, and animation can all be controlled through different dimensions."

" These dimensions can be organized into layers. Since a single dimension or a group of dimensions can be affected through intent, hence, we call it a signal. Signals will be based on intent and can modify a single dimension or a group of dimensions at once. These signals will be powerful enough to express self-documenting intent while we modify or add dimensions that are being affected through those signals. "

" A component not only needs signals that affects its styling, but it also needs signals for passing data and state down to the internal components. These signals that have a value being passed will be called data signals. Data signals carry information down to child components. And those signals where state is being handled internally will be called as state signals. State signals will allow components to manage their own internal reactive state while maintaining clean separation of concerns. "

" The component should be freely owned by the developer so that they could modify it at first as per their website's styling before using them. No developer should use components as they are and should customize them completely at first hand. They should be able to adapt to their website's design system. Therefore, the component should be designed such that it can be easily customized by removing or adding the signals. " 

" To reduce the time spent creating components from scratch, Signal UI will provide pre-built, highly customizable components that can be easily adapted to any design system. Developers can edit once in seconds and use them freely. "

" Developers often end up making similar looking websites with the same provided components with limited configurations. We will design it in a such way that every developer can easily customize it within seconds according to their needs without breaking existing ui. "

" There can be infinite variations and signals for independent dimensions the same way as tailwind css. However, tailwind css cannot group these dimensions together because it's based on utility classes rather than semantic signals. Signal UI will address this by allowing developers to group related dimensions into meaningful signals that express intent clearly. "

" Unlike other UI libraries which either has a complete abstraction layer with dependency code not only with node_packages but also with their documentation to look for different props or another approach where code is completely copyable and ownable however is extremely complex to understand or modify. Signal UI on the other hand will take a middle approach with no dependency on packages and having a simple to understand self-documenting code that is easily ownable and configurable for all use cases. "

## Pain Point That Signal UI Solves

Developers spend too much time configuring components, remembering API docs, and dealing with boilerplate code. Signal UI eliminates these friction points by providing a truly intent-driven, ownable code, and zero-config experience.

Signal Layers provides a clean, intuitive way to build reactive UIs with signals, making your code more readable and maintainable.

It's designed to be simple, flexible, and easy to integrate into any project. Whether you're building a small component or a large application, Signal Layers helps you write cleaner, more maintainable code by reducing boilerplate and providing clear abstractions.

## Comparison

 Comparison Matrix
| Approach | Abstraction | Ownership | Customization |
|----------|-------------|-----------|---------------|
| Traditional UI Libraries | High | Low | Limited |
| Copyable Components | Low | High | Complex |
| Signal UI | Balanced | Full | Simple


## Key Differentiators

No dependency hell - Copy once, own forever.
No variant explosion - Intent-driven signals instead of enums.
No documentation hunting - Self-documenting code.
No design lock-in - Adapt to any design system in seconds.

## Core Principles
Intention over configuration - Express what you want, not how to configure it.
Infinite customization - Modify any component without breaking functionality.
Developer ownership - You own the code, not the library.


Express what you want, not how to configure it.
Components understand intent, not just props.
Code reads like natural language.
Infinite Customization

Single-line modifications without breaking functionality.
Add/remove signals without affecting existing behavior.
Customize once, use infinitely.
Developer Ownership

You own the code, not the library.
No dependency chains or version conflicts.
Modify, extend, or replace any component.
Exact Pain Point (One-Liners)
Configuration Hell

Developers waste hours memorizing API documentation.
Variant props create exponential complexity.
Boilerplate code overwhelms actual functionality.
Design Lock-in

Traditional libraries force their design system.
Copyable components are too complex to modify.
No middle ground between abstraction and ownership.
Maintenance Burden

Component updates break existing functionality.
Version conflicts create dependency hell.
Documentation becomes outdated instantly.
Exact Philosophy (One-Liners)
Signal-Based Architecture

Dimensions define visual/behavioral characteristics.
Signals group dimensions into meaningful intent.
Layers organize signals for semantic clarity.
Self-Documenting Code

Components explain their own capabilities.
No external documentation required.
Intent signals are human-readable.
Zero-Abstraction Balance

No hidden magic or black boxes.
Simple enough to understand immediately.
Powerful enough for production use.
Semantic Grouping

Unlike Tailwind's utility classes, signals group related dimensions.
Intent signals express complete design decisions.
Maintainable through clear semantic meaning.